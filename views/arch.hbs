<div id="main" class=" aui-page-panel" style="margin-left: 55px;">
    <div id="content" class="page view">
        <div id="main-content" class="wiki-content">

            <p><strong>This documentation was lifted from:&nbsp;<a
                    href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/RightmoveArchitecturalPrinciples"
                    class="external-link" rel="nofollow">http://twiki.rightmove.com/twiki/bin/view/Rightmove/RightmoveArchitecturalPrinciples</a></strong>
            </p>

            <p>&nbsp;</p>

            <p>These pages define the characteristics of any application that is ready for production. Any new
                application should follow these guidelines and, where possible, existing applications should be altered
                to do so also. These are characteristics that define how an application should behave and certain
                characterisitcs it should exhibit. How these principles are met internally within an application is
                generally up to a team but the architecture team are available for guidance when required.</p>

            <p></p>

            <h2 id="RightmoveArchitecturalPrinciples-APIDesign">API Design</h2>

            <p>Since the API of your service is a way you are presenting its functionality to the rest of the world (or
                Rightmove in this case) and how every other service will be talking to it, it's important that you think
                about how effective its design is.</p>

            <p><strong>The Robustness Principle</strong></p>

            <p>To start with its worth considering something known as the Robustness Principle, often referred to as
                Postel's Law which is paraphrased below:</p>

            <p><em>"Be conservative in what you send, be liberal in what you accept"</em></p>

            <p>Essentially this means that where you have code that sends commands or data to other services you should
                conform completely to the specifications, but code that receives input should accept non-conforming
                input as long as the meaning is clear. An example of this might be if you had a service that takes in
                maximum and minimum price values and a consuming service only sends a maximum price then your service
                should still allow the input by perhaps providing a default minimum of 0 rather than failing with a
                validation error. Essentially where it makes sense to do so prefer flexibility in what you accept over
                strict validation rules. As always there are exception to the rule where it is important that certain
                rules are still followed for example if your email service isn't supplied an email address to send to
                then this is obviously something that needs to be rejected. Just be careful that you aren't being too
                harsh.</p>

            <p>On the flip-side of this when returning data it should be always be consistent. Results messages from a
                single API must return similarly formatted content in order for consumers of the service to be able to
                handle your responses sensibly and understand them. For example when returning errors you need to ensure
                you always return them in the same way from your service. Also if you accept requests using JSON over
                REST the response should ideally match this format too.</p>

            <p><strong>Design First</strong></p>

            <p>When planning to build an API stop and create a plan for what this is going to look like. You want to
                ensure that consumers of your service and developers coming to look at it are able to reason about what
                the API does based on what it accepts and how it returns its response. This may involve conversations
                with other teams that are planning on using the service to ensure that you are providing the data they
                need. Avoid the trap of making your responses the equivalent of large flat denormalised lists of fields.
                For example there are six fields related to pricing then group them together under a pricing object in
                the response. This will lead to structures that consumers and developers will be able to read and reason
                about.</p>

            <p>If you are designing new APIs it is often worth talking to the Architecture team. They can often help you
                with the design process and ensure that you are not providing functionality available elsewhere.</p>

            <p><strong>Other considerations</strong></p>

            <p>&nbsp;</p>
            <ul>
                <li>It is good to ensure all APIs related to a single resource are grouped together. This makes
                    discovering them easier.
                </li>
                <li>Document your APIs. see the&nbsp;<a class="external-link"
                                                        href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/RightmoveArchitecturalPrinciples#Documentation"
                                                        rel="nofollow">Documentation section</a>&nbsp;for details.
                </li>
                <li>Avoid versioning APIs. This leads to complexity where it is often easier to follow a principle of
                    ensuring changes are backwards compatible. Once you have communicated your changes and the consumers
                    have moved over then you can safely delete fields you no longer need.
                </li>
            </ul>
            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-BoundedContext"><a name="Bounded_Context" rel="nofollow"></a>Bounded
                Context</h2>

            <p>Within any service you create there are things related to the business logic of that application's domain
                that should not be communicated outside of that application and things that should via the application's
                interface. This is often referred to as an application's bounded context. Each bounded context has an
                explicit interface, where it decides what models to share with others. It is important to ensure that
                the consumers of your service have the information they need without needing to know the inner workings
                of how your data was derived or read from.</p>

            <p>For example, in the Rightmove codebase there are certain rules related to calculating display prices for
                property listings. If we expose only the raw data with our property listings then every application that
                uses this data would need to know the business logic for displaying these correctly. However if our
                service that returns the listings data already has the display prices calculated for us then we donâ€™t
                need to expose this logic elsewhere and everyone can show the same prices.</p>

            <p>By confining our bounded contexts to what consumer services actually need it allows business logic to be
                self-contained within an application and easily changed in a single location to be bubbled out amongst
                other services with minimal effort. This also means that business rules are easier to discover and
                reason about.</p>

            <p>Similarly we should avoid having the bounded context of other services cross each other. Otherwise we
                risk tying applications together for release and updating and we can no longer control the business
                logic as easily. If you are uncertain on what should and shouldn't be exposed by your service speak to
                the architecture team and they can help you.</p>

            <h2 id="RightmoveArchitecturalPrinciples-Caching"><a name="Caching" rel="nofollow"></a>Caching</h2>

            <p><strong>Caching external resources</strong></p>

            <p>An application should cache data from external resources, either a database or another service, in the
                following situatuations:</p>
            <ul>
                <li>The dataset is small and static (historically known as 'Type' tables at Rightmove). In this case all
                    the data can be cached for a reasonably long amount of time (e.g. 15mins-1hr)
                </li>
                <li>The data is frequently accessed in the same way. In this case a bounded local cache should be used
                    and appropriately sized to maximise hit-rate whilst minimising memory usage.
                </li>
            </ul>
            <p><span style="color: rgb(0,0,0);">If possible, cache the data as near to the request handler as possible. For instance if your app can cache the combined results from a number of external resources after it has done any data processing on them, that would be ideal. Typically you can use</span><a
                    href="https://spring.io/guides/gs/caching/" class="external-link" rel="nofollow">Spring's own
                caching</a><span style="color: rgb(0,0,0);">&nbsp;or&nbsp;</span><a href="http://www.ehcache.org/"
                                                                                    class="external-link"
                                                                                    rel="nofollow">ehcache</a><span
                    style="color: rgb(0,0,0);">&nbsp;to achieve most of these goals.</span></p>

            <p><strong>Front end assets</strong></p>

            <p>All front end resources should be cacheable by the browser. This includes JavaScript, CSS, fonts and
                images. A very long cache timeout should be set and urls to those resources should be unique to a
                particular version of a resource.</p>

            <p><strong>Distributed caching</strong></p>

            <p>Where it doesn't make sense for instances of an application to have their own copies of cached data, for
                instance if the hit rate would be too low or the data is too large, we can use memcached to cache this
                data. memcached can also be used as an ephemeral datastore for session info â€“ such as randomisation
                seeds for result ordering. The data should be small and your app will need to handle the data going
                missing.</p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Configuration"><a name="Configuration" rel="nofollow"></a>Configuration
            </h2>

            <p>You should consider the environmental, external and application-level configuration your service needs in
                order to run.</p>

            <p><strong>Environmental Configuration</strong></p>

            <p>This is provisioned by Operations using Puppet. It describes the host configuration needed for the
                application to run. An example would be the Java runtime and JAVA_OPTS variable.</p>

            <p><strong>External Configuration</strong></p>

            <p>This is configuration specific to the application that will change between environments. It should have a
                different lifecycle to the application. Mostly this should be addresses of external services, and should
                be as minimal as possible.</p>

            <p><strong>Application Configuration</strong></p>

            <p>This is configuration specific to the application that has the same lifecycle and does not vary between
                environments. These should be sensible defaults that you may want to override in certain circumstances.
                A good example would be a Hystrix timeout setting. This may need to be changed in Production at a
                moments notice, and may be something you would want to test out on different environments before
                updating the defaults in the application.</p>

            <h2 id="RightmoveArchitecturalPrinciples-DataStores"><a name="Data_Stores" rel="nofollow"></a>Data Stores
            </h2>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-DecouplingApplications"><a name="Decoupling_Applications"
                                                                                rel="nofollow"></a>Decoupling
                Applications</h2>

            <p>It is important to ensure that our applications remain decoupled. This means that we should be able to
                release applications independently wherever possible. This means making sure that changes to APIs used
                in other applications are non-breaking and remain backwards compatible when necessary. This might mean
                keeping fields in API responses until all consumer apps have been updated to use a replacement field or
                not adding mandatory parameters until all consumer apps are updated to handle this.</p>

            <p>To ensure this we use language agnostic JSON/HTTP APIs and each inter-app relationship should have
                associated&nbsp;<a class="external-link"
                                   href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/CDCOverview"
                                   rel="nofollow">consumer-driven contract tests</a>. More details on these can be found
                in the&nbsp;<a class="external-link"
                               href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/RightmoveArchitecturalPrinciples#Protocols"
                               rel="nofollow">Protocols</a>&nbsp;and&nbsp;<a class="external-link"
                                                                             href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/RightmoveArchitecturalPrinciples#Testing"
                                                                             rel="nofollow">Testing</a>&nbsp;sections.
            </p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-DeploymentPipeline"><a name="Deployment_Pipeline"
                                                                            rel="nofollow"></a>Deployment Pipeline</h2>

            <p>All changes should be promoted through CI and QA environments before they can be deployed to production.
                This ensures consistency and that the same testing is applied to every change. Pipeline are a useful way
                to visualise and orchestrate this progresion from commit to production.</p>

            <p><strong>Deployment gateways</strong></p>

            <p>Applications should be deployed by the deployment servers (hx-xbad01). Currently only Jenkins has
                permission to issue these deployment commands. The deployment server will then manage the
                deployments.</p>

            <p><strong>Auditing</strong></p>

            <p>Your deployment pipeline should be able to identify who triggered the deployment. If automated, this
                should be traceable back to the original commit. If manual, users should be logged.</p>

            <p><strong>Deploying to different environment</strong></p>

            <p>Production deployments should be manual triggered and not automated. It should be a conscious choice,
                with the consequences considered first. Operations should be consulted before attempting production
                deployments in case of any current issues or work that may threaten availability.</p>

            <p><strong>Separating releases from deployment</strong></p>

            <p>Continuous Delivery promotes the idea that you should separate deployment of code from releases of
                features. By placing new features behind switches, code deployments by the teams are separated from the
                business capability of releasing a new feature. This enables you to have a new feature deployed out to
                all hosts before you turn it on.</p>

            <h2 id="RightmoveArchitecturalPrinciples-Documentation"><a name="Documentation" rel="nofollow"></a>Documentation
            </h2>

            <p><strong><a href="http://README.md" class="external-link" rel="nofollow">README.md</a></strong></p>

            <p>Each deployable applicationâ€™s project should have a <a href="http://README.md" class="external-link"
                                                                      rel="nofollow">README.md</a> file at the root of
                its source control repository. This file should document what the application is and what it does at a
                high level. It should cover what external dependencies it relies on (e.g. database or other services).
                It should also contain a short guide on how to run the app in development. If there are any other forms
                of documentation, such as auto-generated REST API documentation, links to these should be provided in
                the README.</p>

            <p><strong>Documenting the code</strong></p>

            <p>Good design of an API (see above) is the first step to a usable API. Internal behaviour within a codebase
                should be documented using tests and self-documenting code. For any public API (something that could be
                consumed within another application) you should provide accessible documentation. This should take the
                following forms:</p>

            <p><em>REST APIs</em>&nbsp;<br>You should provide some level of documentation for all exposed RESTful APIs.
                This can be auto generated with technologies like&nbsp;<a href="http://swagger.io/"
                                                                          class="external-link"
                                                                          rel="nofollow">Swagger</a>. Technologies like
                Swagger should&nbsp;<strong>only</strong>&nbsp;be available in pre-production instances of your
                application.</p>

            <p><em>Code-level documentation</em>&nbsp;<br>If your project is a shared JavaScript or Java library, you
                should provide enough relevant documentation for anyone to be able to use the code and understand what
                it does. This documentation should take the form of Javadoc (or something Javadoc-like, e.g.<a
                        href="http://usejsdoc.org/" class="external-link" rel="nofollow">JSDoc</a>, for JavaScript) that
                covers the publicly exposed parts of your codebase (or those parts that you want external consumers to
                use). This should be published to Nexus as part of any build of the library through CI.</p>

            <p><em>Documenting changes</em>&nbsp;<br>Each shared library repository should also contain a <a
                    href="http://CHANGELOG.md" class="external-link" rel="nofollow">CHANGELOG.md</a> file that lists the
                major changes made to each version of that library as a list of changes under the version that the
                change was made.</p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Libraries"><a name="Libraries" rel="nofollow"></a>Libraries</h2>

            <p>Itâ€™s often tempting to share code between application services under the concept of Donâ€™t Repeat
                Yourself. However this can sometimes lead to tying applications together or leaking business logic that
                is specific to an applicationâ€™s bounded context outside of the application. In these cases it is better
                to ensure the right service has the logic within its bounded context and supplies APIs to allow other
                applications to access the data they need.</p>

            <p>In the cases where you wish to share code that addresses a cross-cutting concern that is unrelated to an
                application's context, like logging, message handling or analytics for example, this is where you may
                wish to create shared libraries.</p>

            <p>Libraries should follow the following requirements to ensure they remain reusable and donâ€™t pollute
                application code bases:</p>
            <ul>
                <li>They should have a small public API - If your application has a small entry point then it allows
                    developers who use it to reason about what it does more easily and know how to interact with it.
                </li>
                <li>They should be documented â€“ Tools like Javadoc/JSdoc and <a href="http://README.md"
                                                                                class="external-link" rel="nofollow">README.md</a>
                    files should all be used to adequately document the functionality of your library so that the
                    developer using it knows how to integrate and interact with it with minimal specialist knowledge.
                </li>
                <li>They should not leak dependencies â€“ when relying on things like Spring, Guava or Apache libraries in
                    your code ensure that these dependencies do not leak outside your application. This can be done by
                    defining dependency requirement in your README and using provided scope in your Gradle files.
                </li>
                <li>The core of your library should be framework agnostic â€“ Things like Spring code should be separated
                    out into a separate submodule of your library. This allows developers not using a Spring Web
                    application to use your code too. It also means the core functionality of your library is separated
                    from its wiring code make it easier to refactor and test.
                </li>
                <li>There should be no business or domain logic in your library â€“ this belongs in a service not a
                    library.
                </li>
                <li>You should provide a changelog â€“ If you want developers to use your library and upgrade when you
                    have fixes and features it is a good idea to note somewhere what has changed between versions. It is
                    up to you and your team to ensure this is kept up to date.
                </li>
            </ul>
            <p><span style="color: rgb(0,0,0);">If you are thinking of creating a shared library speak to the architecture as they can help you figure out what or if itâ€™s required.</span>
            </p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Logging"><a name="Logging" rel="nofollow"></a>Logging</h2>

            <p>Using the internal&nbsp;<a href="http://git.rightmove.com/projects/LIB/repos/logging/browse"
                                          class="external-link" rel="nofollow">logging library</a>&nbsp;in a spring boot
                app, along with proper Log4j2 configuration like&nbsp;<a class="external-link"
                                                                         href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/ExampleLog4J2Config"
                                                                         rel="nofollow">this</a>&nbsp;will auto
                configure everything necessary to achieve these requirements.</p>

            <p><strong>Requests into an application</strong></p>

            <p>All incoming requests should be logged in our customised version of the standard Apache HTTP Combined Log
                Format, exact details of which can be found&nbsp;<a class="external-link"
                                                                    href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/RequestLogging"
                                                                    rel="nofollow">here</a>.</p>

            <p><strong>Outgoing requests to external HTTP applications</strong></p>

            <p>We should log the outgoing requests to other external services, both when they are sent and when the
                response are recieved along with the status code and response size.</p>

            <p><strong>Application logging</strong></p>

            <p>Your application should log anything log levels should be used correctly, so any given log statement
                should have the most suitable log level associated with it (see&nbsp;<a
                        href="http://www.slf4j.org/apidocs/org/apache/log4j/Level.html" class="external-link"
                        rel="nofollow">here</a>&nbsp;for good definitions. We wouldn't want to run an application in
                anything above INFO logging for normal operations, so all necessary logging required to monitor the
                normal running of an application should be under INFO. You will need to ensure that the logging at the
                standard log level will not produce too much logging and exhaust available disk space.</p>

            <p><strong>Log rotation</strong></p>

            <p>Logs should be rotated by the application so a new file is appended to every day. Logs should have a
                naming pattern that shows what date the logs are associated with. The application should not compress
                the logs on rotation</p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Messaging(Kafka)"><a name="Messaging_Kafka" rel="nofollow"></a>Messaging
                (Kafka)</h2>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Monitoring"><a name="Monitoring" rel="nofollow"></a>Monitoring</h2>

            <p>If you plan to release code to the big wide world its worth knowing that it is performing and work as you
                expect it to. This is where monitoring comes in. Monitors allow you and your team to record and track
                the stability of your services and should something go wrong provide something to both alert you of this
                fact and also give you information on what it was that happened and when.</p>

            <p>Whilst the monitoring of system hardware is generally handled by the Operations team this is generally
                not enough to ensure an application is functioning correctly. An application that indexes data for
                example can be operating within good hardware parameters and still stop indexing data. It is therefore
                really important that you and your team setup the monitoring they need to know the system is
                working.</p>

            <p>Setting up monitoring can often be a daunting prospect, after all how do you know what you want to know
                about before it has gone wrong? A good place to start is by thinking about what your service does. If it
                returns search results of some kind then you probably want a monitor that performs a search periodically
                and ensures that results are returned. If it indexes data then you will want to know when it last did so
                or perhaps setup test monitoring data to be updated periodically and then write a monitor to ensure that
                it was updated by your service.</p>

            <p>Another good thing to think about is what data-sources your application uses. If those sources become
                uncontactable you will want to know about it so monitors around your applications connections to these
                are important too.</p>

            <p>Other examples of things you might want to monitor are the number of incomplete requests, the sizes and
                hit and miss rates of your caches, number of busy connections and the number of errors your application
                is producing.</p>

            <p>It is worth noting that there needs to be a source for your monitors. Health check endpoints within your
                applications can help with this alongside the contents of your application logs. If you do use logs
                please make sure that these are specialised for purpose otherwise you will need to filter a lot of
                information to get what you need. Naming your threads in your application is also important so that
                should you need any diagnostic stack traces that you can tell what each thread in your application is
                and what it was doing.</p>

            <p>If you are in any doubt about what monitoring your application needs and how to set it up then the
                Platforms and Operations teams can help you define these with you.</p>

            <h2 id="RightmoveArchitecturalPrinciples-OperationalRequirements"><a name="Operational_Requirements"
                                                                                 rel="nofollow"></a>Operational
                Requirements</h2>

            <p>When creating a new application, the following information should be provided to the Operations team when
                you are requesting hardware to be provisioned (this should be after having a conversation with
                them!):</p>

            <p>&nbsp;</p>
            <ul>
                <li>The three letter code associated with the service (this is used to name the provisioned zones/vms)
                </li>
                <li>Whether an Oracle DB user is required - this will mean the username and password can set up and be
                    securely provisioned to the boxes
                </li>
                <li>Whether a Vertica user required - same as Oracle above</li>
                <li>Load balancer strategy -
                    <ol>
                        <li>Does your service require site affinity to the calling service</li>
                        <li>Does your service require site affinity based on some unique identifier, such as user id?
                        </li>
                        <li>Does your service&nbsp;<em>prefer</em>&nbsp;site affinity, can it fall back to alternative
                            sites when the preferred one is unavailable
                        </li>
                        <li>Can the service be completely stateless, where it doesn't matter which instance is called
                        </li>
                    </ol>
                </li>
                <li>Whether the service requires external connectivity (e.g. to talk to an external 3rd party service)
                </li>
                <li>How much memory (RAM) the service should have set aside.</li>
                <li>Number of predicted CPU threads the application needs to operate</li>
                <li>Amount of disk space the application will need to operate - mostly for logging purposes (see the&nbsp;<a
                        class="external-link"
                        href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/RightmoveArchitecturalPrinciples#Logging"
                        rel="nofollow">logging</a>&nbsp;section above).
                </li>
                <li>What the predicted network utilisation of any application will be. This is to ensure that any
                    application will not add any undue load to the network.
                    <ul>
                        <li>This can be mitigated by ensuring that as many inter-service calls are batched and no
                            unnecessary calls are made.
                        </li>
                    </ul>
                </li>
            </ul>
            <p><span style="color: rgb(0,0,0);">Any new application should be added to the&nbsp;</span><a
                    class="external-link" href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/ApplicationOwners"
                    rel="nofollow">Application Owners</a><span style="color: rgb(0,0,0);">&nbsp;page along with any other relevant information.</span>
            </p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Protocols"><a name="Protocols" rel="nofollow"></a>Protocols</h2>

            <p><strong>REST protocol</strong></p>

            <p>Where possible HTTP should be used as the protocol in which to implement REST, with the following
                alteration; Use GETs only when retrieving data, POSTs are better for calls that result in the creation
                or alteration of data.</p>

            <p><strong>REST formats</strong></p>

            <p>JSON is mandatory. XML is optional. RMI is forbidden (coupling...ahem).</p>

            <p><strong>HTTP Response codes</strong></p>

            <p>You should use HTTP response codes to reflect the state of service to consumers. If the application
                experiences an error the correct response code should be used. It is your responsability to&nbsp;<span>ensure the correct use and handling of responses.</span>
            </p>

            <h2 id="RightmoveArchitecturalPrinciples-Resilience"><a name="Resilience" rel="nofollow"></a>Resilience</h2>

            <p>Any distributed system must be designed to handle failure. There will be times when your applications
                dependent services or data stores become unavailable and your application should handle this as
                gracefully as possible.</p>

            <p><strong>Circuit Breakers</strong></p>

            <p>Circuit breakers are a pattern that are used to wrap any code that interacts with a volatile resource. At
                the most basic level they monitor all interactions with such resources, monitor error rates and response
                times and will 'open' when any pre-defined thresholds in those metrics are exceeded. Your application
                should use a circuit breakers around communication with any external service. This means that if an
                external service is slow or down, we can detect that and start&nbsp;<a
                        href="https://en.wikipedia.org/wiki/Fail-fast" class="external-link" rel="nofollow">failing
                    fast</a>. We do this so failures in dependencies don't cause a cascading failure in your application
                because everything is backing up within your application. It also means we can use fallbacks where
                possible, or ignore the failure if it is for a non-essential component.&nbsp;<a
                        href="https://github.com/Netflix/Hystrix" class="external-link" rel="nofollow">Hystrix</a>&nbsp;provides
                all of these features out of the box and can be easily integrated with Spring Boot apps with&nbsp;<a
                        href="http://projects.spring.io/spring-cloud/" class="external-link" rel="nofollow">Spring
                    Cloud</a>.</p>

            <p><strong>Connection Pools</strong></p>

            <p>When dealing with a database resource over JDBC, connection pools should be used to manage all
                connections. This allows us to set relevant timeouts, reconnection mechanisms and means we don't incur
                the overhead of initiating a connection to a database every time we need one. Your application should
                survive the restart or outage of a database and be able to reconnect when it is available.</p>

            <p><strong>Bulkheading</strong></p>

            <p>Bulkheading is a pattern that ensures that parts of an application that deal with different resources,
                often external services, have logical splits from other parts of the application. This is often achieved
                using separate thread or connection pools to process anything to do with those different resources.
                Again,&nbsp;<a href="https://github.com/Netflix/Hystrix" class="external-link"
                               rel="nofollow">Hystrix</a>&nbsp;provides this.</p>

            <p><strong>Recoverability</strong></p>

            <p>Your application should survive the outage of dependent service. It should not need a restart. It might
                not be able to return good responses during an outage of a dependent service, but it should at least
                respond within the constraints of any timeouts.</p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Scalability"><a name="Scalability" rel="nofollow"></a>Scalability
            </h2>

            <p>In order for our apps to handle the large volumes of traffic we get as part of their day-to-day use we
                need to try to factor in scalability into their design. This essentially means that should load increase
                we have options like increasing threading or adding extra instances that will enable us to handle higher
                load.</p>

            <p>Scalability is often tied to the way your application communicates with external services and data
                stores. For example if we use a new connection every time we call the database then we can quickly
                overwhelm it and our application will slowdown. In this case connection pooling would help alievate the
                issue by using a pool of reusable connections. A pattern called Bulkheading can also be used where by
                certain APIs can be handled by their own resources like connection pools so for example in a service
                that handles both indexing and querying data that slow indexing doesn't tie up the connections used for
                querying your data and make you application scale badly under heavy indexing load.</p>

            <p>Scalability can also be tied to memory usage. Ensuring your application remains stateless is a good way
                to avoid using too much memory as well as ensuring that adding extra instances doesnâ€™t entail them
                having to be aware of each otherâ€™s state and also avoiding issues where multiple threads have to
                synchronise on data or risk it being inconsistent. If you find yourself needing to save data between
                requests then use a data store. Caching (see the section above) is also a good way of ensuring your
                application scales as it relieves pressure on requests to external services and ensures if the same data
                is requested within a reasonable time limit that the work to fetch it is not replicated u<span>nnecessarily</span><span>.</span>
            </p>

            <p>It is also worth noting that simply supplying a single application with a means to up its request threads
                or connections between services doesnâ€™t mean that the application it is communicating to is capable of
                handling this load. In order to figure out what each application can handle it is worth writing load
                tests to test the boundaries of your application.</p>

            <p>Tools for performance testing that are recommended are Gatling for load tests (<a
                    href="http://gatling.io/" class="external-link" rel="nofollow">http://gatling.io</a>) and Wiremock
                for stubbing services (<a href="http://wiremock.org/" class="external-link" rel="nofollow">http://wiremock.org/</a>).
                There is also a performance testing environment available to test on. Speak to the platforms team for
                information if you want to run load tests and they can help you set them up.</p>

            <h2 id="RightmoveArchitecturalPrinciples-Security"><a name="Security" rel="nofollow"></a>Security</h2>

            <p><strong>Passwords</strong></p>

            <p>Any password or authentication key should be stored in a secure manner. For database passwords, we store
                these in a secure.properties file on the host where the passwords are encrypted. Using the&nbsp;<a
                        href="http://git.rightmove.com/projects/LIB/repos/secure-properties-utils/browse"
                        class="external-link" rel="nofollow">secure-properties-utils</a>&nbsp;library in your
                application will allow you to use these passwords. If using spring boot, simply importing the
                secure-properties-spring module from that library will allow you to use passwords in those files with no
                extra confiuration required. We should&nbsp;<strong>never store these passwords in plaintext
                    anywhere</strong>.</p>

            <p><strong>Publicly accessible resources</strong></p>

            <p>If your application is available over the internet and any sensitive or personal information is passed
                through it, it must be made available over SSL only. You will need to speak to opertations to get this
                set up. If the application also results in any writes to our database (other than tracking), you should
                also perform authentication on any incoming request that triggers such an update. The actual updating of
                the data should be performed by a service that is only presented internally.</p>

            <p><strong>Security Policy</strong></p>

            <p>All our application should adhere to our internal security policy. See&nbsp;<span class="twikiNewLink"><a
                    href="http://twiki.rightmove.com/twiki/bin/edit/Twiki/rightmove/com/twiki/bin/view/Security/SecurityPolicies?topicparent=Rightmove.RightmoveArchitecturalPrinciples;nowysiwyg=0"
                    rel="nofollow" class="external-link">here</a></span>&nbsp;for details.</p>

            <h2 id="RightmoveArchitecturalPrinciples-Testing"><a name="Testing" rel="nofollow"></a>Testing</h2>

            <p>Behaviours of the system should be covered by automated testing where possible to minimise regressions
                and aid future maintenance of the code base. Tests at all levels are the equal and joint responsability
                of the developers and testers. These two roles should work together to write and maintain the test
                suite, making sure that the tests are kept up to date and are providing value. In Continuous Delivery,
                the aim of testing is to provide as fast feedback as possible on the impact of every change. You should
                always be asking if there is a way you can get feedback faster on your changes.</p>

            <p><strong>Consumer Driven Contracts</strong></p>

            <p>As well as the now standard Unit, ATDD/BDD, Integration/Functional/End-to-End and Visual Regression
                tests, with microservices you must also test the contract between services to maintain API fidelity.&nbsp;<a
                        class="external-link" href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/CDCOverview"
                        rel="nofollow">Consumer Driven Contracts</a>&nbsp;should exist between any service that
                consumers another, and these should be checked whenever the consumer or provider changes. Pact is the
                tool we currently use for this.</p>

            <p><strong>Smoke Tests</strong></p>

            <p>Your service should also have smoke tests. Smoke tests have one aim, to assert that the services does the
                thing it is meant to do. For example, on PVW a user can perform a search and see results, LPW can serve
                adverts, USA can authenticate a user. These tests should be simple, fast and be usable as a health
                monitor to tell you if the application is functioning as required. Smoke tests should be run after an
                application has been deployed. This asserts that it starts up in a valid state.</p>

            <p><strong>Performance Testing</strong></p>

            <p>You should stress test your service in isolation using a test harness. This should be performed after
                every change, but should not block the deployment pipelines incase of emergency fixes. These tests
                should use real logs to mimic actual load. In addition to those performance tests that cover your
                application during normal operation, you should include tests that hit your application when its
                external resources are failing or responding slowly. In the performance test environment, we have a tool
                called&nbsp;<a href="https://github.com/tomakehurst/saboteur" class="external-link" rel="nofollow">saboteur</a>available
                on the box that wiremock is deployed to in order to simulate this.</p>

            <p><strong>Hypothesis Testing</strong></p>

            <p>You should test all the hypotheses you have about how changes will improve the system by using an A/B
                testing framework (Think of&nbsp;<a class="external-link"
                                                    href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/MVT"
                                                    rel="nofollow">MVT</a>&nbsp;as just A/B/C testing). Any change that
                could impact KPI's should be tested this way. You can use the feature-swtiches project (<a
                        href="http://git.rightmove.com/projects/LIB/repos/feature-switches/browse" class="external-link"
                        rel="nofollow">http://git.rightmove.com/pr ojects/LIB/repos/f eature-switches/browse</a>) to
                orchestrate this.</p>

            <p>For details on the types of testing you should be thinking about using see (<a
                    href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/Testing" class="external-link"
                    rel="nofollow">http://twiki.rightmove.c om/twiki/bin/view/Ri ghtmove/Testing</a>,&nbsp;<a
                    href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/TestingProcess" class="external-link"
                    rel="nofollow">http://twiki.rightmov e.com/twiki/bin/view/Rightmov e/TestingProcess</a>).</p>

            <p>&nbsp;</p>

            <h2 id="RightmoveArchitecturalPrinciples-Versioning"><a name="Versioning" rel="nofollow"></a>Versioning</h2>

            <p><strong>Software Libraries</strong></p>

            <p>For consistancy you should use SemVer for versioning (<a href="http://semver.org/" class="external-link"
                                                                        rel="nofollow">http://semver.org/</a>). There
                needs to be a standard and this one is good enough.</p>

            <p>It is up to you to choose if you want to use autoversioning or manually maintain the version. Whichever
                you choose you are responsible for keeping the version up to date and accurate.</p>

            <p><strong>API Versioning</strong></p>

            <p>There is no explicit API versioning. Contracts will be enforced using CDC testings (See Testing section&nbsp;<a
                    class="external-link"
                    href="http://twiki.rightmove.com/twiki/bin/view/Rightmove/RightmoveArchitecturalPrinciples#Testing"
                    rel="nofollow">here</a>).</p>


        </div>

        <!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/">
         <rdf:Description
    rdf:about="https://rightmove.atlassian.net/wiki/display/PLAT/Rightmove+Architectural+Principles"
    dc:identifier="https://rightmove.atlassian.net/wiki/display/PLAT/Rightmove+Architectural+Principles"
    dc:title="Rightmove Architectural Principles"
    trackback:ping="https://rightmove.atlassian.net/wiki/rpc/trackback/1507341"/>
</rdf:RDF>
-->


        <div id="likes-and-labels-container">
            <div id="likes-section"><a href="" class="like-button"><span
                    class="aui-icon aui-icon-small aui-iconfont-like"></span><span class="like-button-text">Like</span></a><span
                    class="like-summary">Be the first to like this</span></div>
            <div id="labels-section" class="pageSection group">
                <div class="labels-section-content content-column" entityid="1507341" entitytype="page">
                    <div class="labels-content">

                        <ul class="label-list label-list-right  has-pen">
                            <li class="no-labels-message">
                                No labels
                            </li>
                            <li class="labels-edit-container">
                                <a href="#" class="show-labels-editor" title="Edit Labels (l)">
                                    <span class="aui-icon aui-icon-small aui-iconfont-edit-small">Edit Labels</span>
                                </a>
                            </li>
                        </ul>

                    </div>
                </div>
            </div>
        </div>


        <div id="comments-section" class="pageSection group">


            <div class="bottom-comment-panels comment-panels">


                <div class="quick-comment-container comment add"><p class="comment-user-logo"><a
                        class="userLogoLink userlink-1" data-username="Confluence@rightmove.co.uk"
                        href="/wiki/display/~Confluence%40rightmove.co.uk" title="" data-user-hover-bound="true"><img
                        class="userLogo logo" src="/wiki/download/attachments/1507339/user-avatar"
                        alt="User icon: Confluence@rightmove.co.uk" title=""></a></p>

                    <div class="quick-comment-body">
                        <div class="quick-comment-loading-container" style="display:none;"></div>
                        <div id="editor-messages"></div>
                        <div id="all-messages"></div>
                        <form style="display:block;" class="quick-comment-form aui" method="post"
                              name="inlinecommentform" action="/wiki/pages/doaddcomment.action?pageId=1507341">
                            <div title="Add a Comment (m)" class="quick-comment-prompt"><span>Write a commentâ€¦</span>
                            </div>
                        </form>
                    </div>
                </div>

            </div>

            <div id="comments-actions" class="aui-toolbar noprint" style="display: none;">
                <p class="toolbar-group">
                    <span class="toolbar-item"><a
                            href="/wiki/display/PLAT/Rightmove+Architectural+Principles?showComments=true&amp;showCommentArea=true#addcomment"
                            id="add-comment-rte" accesskey="m" class="toolbar-trigger">Add Comment</a></span>
                </p>
            </div>
        </div>

    </div>
    <div id="space-tools-web-items" class="hidden">
        <div data-label="Overview" data-href="/wiki/spaces/viewspacesummary.action?key=PLAT">Overview</div>
        <div data-label="Content Tools" data-href="/wiki/pages/reorderpages.action?key=PLAT">Content Tools</div>
    </div>
</div>